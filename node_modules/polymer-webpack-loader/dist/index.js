'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = entry;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _dom = require('dom5');

var _loaderUtils = require('loader-utils');

var _loaderUtils2 = _interopRequireDefault(_loaderUtils);

var _htmlMinifier = require('html-minifier');

var _parse = require('parse5');

var _parse2 = _interopRequireDefault(_parse);

var _espree = require('espree');

var _espree2 = _interopRequireDefault(_espree);

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var domPred = _dom.predicates.AND(_dom.predicates.hasTagName('dom-module'));
var linkPred = _dom.predicates.AND(_dom.predicates.hasTagName('link'));
var scriptsPred = _dom.predicates.AND(_dom.predicates.hasTagName('script'));

var ProcessHtml = function () {
  function ProcessHtml(content, loader) {
    _classCallCheck(this, ProcessHtml);

    this.content = content;
    this.options = _loaderUtils2.default.getOptions(loader) || {};
    this.currentFilePath = loader.resourcePath;
  }
  /**
   * Process `<link>` tags, `<dom-module>` elements, and any `<script>`'s.
   * Return transformed content as a bundle for webpack.
   */


  _createClass(ProcessHtml, [{
    key: 'process',
    value: function process() {
      var links = this.links();
      var doms = this.domModule();
      return this.scripts(links.source + doms.source, links.lineCount + doms.lineCount);
    }
    /**
     * Look for all `<link>` elements and turn them into `import` statements.
     * e.g.
     * ```
     * <link rel="import" href="paper-input/paper-input.html">
     * becomes:
     * import 'paper-input/paper-input.html';
     * ```
     * @return {{source: string, lineCount: number}}
     */

  }, {
    key: 'links',
    value: function links() {
      var _this = this;

      var doc = _parse2.default.parse(this.content, { locationInfo: true });
      (0, _dom.removeFakeRootElements)(doc);
      var links = (0, _dom.queryAll)(doc, linkPred);

      var source = '';
      var ignoreLinks = this.options.ignoreLinks || [];
      var ignoreLinksFromPartialMatches = this.options.ignoreLinksFromPartialMatches || [];
      var ignorePathReWrites = this.options.ignorePathReWrite || [];
      var lineCount = 0;
      links.forEach(function (linkNode) {
        var href = (0, _dom.getAttribute)(linkNode, 'href') || '';
        var path = '';
        if (href) {
          var checkIgnorePaths = ignorePathReWrites.filter(function (ignorePath) {
            return href.indexOf(ignorePath) >= 0;
          });
          if (checkIgnorePaths.length === 0) {
            path = _path2.default.join(_path2.default.dirname(_this.currentFilePath), href);
          } else {
            path = href;
          }

          var ignoredFromPartial = ignoreLinksFromPartialMatches.filter(function (partial) {
            return href.indexOf(partial) >= 0;
          });

          if (ignoreLinks.indexOf(href) < 0 && ignoredFromPartial.length === 0) {
            source += `\nimport '${path}';\n`;
            lineCount += 2;
          }
        }
      });
      return {
        source,
        lineCount
      };
    }
    /**
     * Looks for all `<dom-module>` elements, removing any `<script>`'s without a
     * `src` and any `<link>` tags, as these are processed in separate steps.
     * @return {{source: string, lineCount: number}}
     */

  }, {
    key: 'domModule',
    value: function domModule() {
      var doc = _parse2.default.parse(this.content, { locationInfo: true });
      (0, _dom.removeFakeRootElements)(doc);
      var domModule = (0, _dom.query)(doc, domPred);
      var scripts = (0, _dom.queryAll)(doc, scriptsPred);
      scripts.forEach(function (scriptNode) {
        var src = (0, _dom.getAttribute)(scriptNode, 'src') || '';
        if (src) {
          var parseSrc = _url2.default.parse(src);
          if (!parseSrc.protocol || !parseSrc.slashes) {
            (0, _dom.remove)(scriptNode);
          }
        } else {
          (0, _dom.remove)(scriptNode);
        }
      });
      var links = (0, _dom.queryAll)(doc, linkPred);
      links.forEach(function (linkNode) {
        (0, _dom.remove)(linkNode);
      });
      var html = domModule ? domModule.parentNode : doc;
      var minimized = (0, _htmlMinifier.minify)(_parse2.default.serialize(html), {
        collapseWhitespace: true,
        conservativeCollapse: true,
        minifyCSS: true,
        removeComments: true
      });
      if (minimized) {
        if (domModule) {
          return {
            source: `
const RegisterHtmlTemplate = require('polymer-webpack-loader/register-html-template');
RegisterHtmlTemplate.register('${minimized.replace(/'/g, "\\'")}');
`,
            lineCount: 3
          };
        }
        return {
          source: `
const RegisterHtmlTemplate = require('polymer-webpack-loader/register-html-template');
RegisterHtmlTemplate.toBody('${minimized.replace(/'/g, "\\'")}');
`,
          lineCount: 3
        };
      }
      return {
        source: '',
        lineCount: 0
      };
    }
    /**
     * Look for all `<script>` elements. If the script has a valid `src` attribute
     * it will be converted to an `import` statement.
     * e.g.
     * ```
     * <script src="foo.js">
     * becomes:
     * import 'foo';
     * ```
     * Otherwise if it's an inline script block, the content will be serialized
     * and returned as part of the bundle.
     * @param {string} initialSource previously generated JS
     * @param {number} initialLineOffset number of lines already in initialSource
     * @return {{source: string, sourceMap: Object=}}
     */

  }, {
    key: 'scripts',
    value: function scripts(initialSource, initialLineOffset) {
      var _this2 = this;

      var lineOffset = initialLineOffset;
      var doc = _parse2.default.parse(this.content, { locationInfo: true });
      (0, _dom.removeFakeRootElements)(doc);
      var scripts = (0, _dom.queryAll)(doc, scriptsPred);
      var source = initialSource;
      var sourceMapGenerator = null;
      scripts.forEach(function (scriptNode) {
        var src = (0, _dom.getAttribute)(scriptNode, 'src') || '';
        if (src) {
          var parseSrc = _url2.default.parse(src);
          if (!parseSrc.protocol || !parseSrc.slashes) {
            var path = _path2.default.join(_path2.default.dirname(_this2.currentFilePath), src);
            source += `\nimport '${path}';\n`;
            lineOffset += 2;
          }
        } else {
          var scriptContents = _parse2.default.serialize(scriptNode);
          sourceMapGenerator = sourceMapGenerator || new _sourceMap2.default.SourceMapGenerator();
          var tokens = _espree2.default.tokenize(scriptContents, {
            loc: true,
            ecmaVersion: 2017,
            sourceType: 'module'
          });

          // For script node content tokens, we need to offset the token position by the
          // line number of the script tag itself. And for the first line, offset the start
          // column to account for the <script> tag itself.
          var currentScriptLineOffset = scriptNode.childNodes[0].__location.line - 1; // eslint-disable-line no-underscore-dangle
          var firstLineCharOffset = scriptNode.childNodes[0].__location.col; // eslint-disable-line no-underscore-dangle
          tokens.forEach(function (token) {
            if (!token.loc) {
              return;
            }
            var mapping = {
              original: {
                line: token.loc.start.line + currentScriptLineOffset,
                column: token.loc.start.column + (token.loc.start.line === 1 ? firstLineCharOffset : 0)
              },
              generated: {
                line: token.loc.start.line + lineOffset,
                column: token.loc.start.column
              },
              source: _this2.currentFilePath
            };

            if (token.type === 'Identifier') {
              mapping.name = token.value;
            }

            sourceMapGenerator.addMapping(mapping);
          });
          source += `\n${scriptContents}\n`;
          // eslint-disable-next-line no-underscore-dangle
          lineOffset += 2 + (scriptNode.__location.endTag.line - scriptNode.__location.startTag.line);
        }
      });
      var retVal = {
        source
      };
      if (sourceMapGenerator) {
        sourceMapGenerator.setSourceContent(this.currentFilePath, this.content);
        retVal.sourceMap = sourceMapGenerator.toJSON();
      }
      return retVal;
    }
  }]);

  return ProcessHtml;
}();

// eslint-disable-next-line no-unused-vars


function entry(content, map) {
  var results = new ProcessHtml(content, this).process();
  this.callback(null, results.source, results.sourceMap);
}